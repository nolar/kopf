"""
Parse a SSL cert (file or blob) and extract its validity timestamps.

The sole purpose of this module is to refresh the webhook server certificate
once the external certificate expires (e.g., the one from certmanager).
We do not parse and anything except the "notBefore" and "notAfter" fields.

An alternative is to install the proper libraries to parse the SSL certificates,
such as ``cryptography`` (too heavy: 8-9 MB) or ``oscrypto`` (2-3 MB);
the latter one is already in the ``dev`` extras, but not guaranteed normally.
Kopf keeps the image and disk footprint as small as possible, as it is supposed
to be with the lightweight operators, so it avoids the heavy dependencies.

Another alternative: using StdLib's hidden undocumented function from
an undocumented module -- ``_ssl._test_decode_cert`` -- but this is unreliable:

.. code-block:: python

    import _ssl
    import ssl
    import datetime

    def parse_cert_notafter(cert_data: bytes) -> tuple[datetime.datetime, datetime.datetime]:
        cert_info = _ssl._test_decode_cert(cert_data)
        not_before = ssl.cert_time_to_seconds(cert_info['notBefore'])  # RFC 5280
        not_after = ssl.cert_time_to_seconds(cert_info['notAfter'])  # RFC 5280
        return not_before, not_after

The parser below is generated by AI; the approximate prompt:

> Using Python, decode an SSL cert from a file or a binary blob (not a peercert)
> and extract its "notBefore" and "notAfter" validity timestamps.
> Use only the StdLib, no external dependencies, no command-line tools.

Security is not a concern here: the certificate file or blob comes from
the developer or the infrastructure where the operator runs (e.g., certmanager),
so it is fully trusted. In the worst case of a damaged certificate,
the parser will fail and raise a ``ValueError``, which is then interpreted
as the absence of the notBefore/notAfter fields (in the :class:`WebhookServer`).
Having the cert files replaced with malicious certificates is a bigger problem
then the failed parsing of those, and it is out of scope of the operator(s).
"""
import datetime
import re
import ssl
from typing import NamedTuple


class CertValidity(NamedTuple):
    not_before: datetime.datetime
    not_after: datetime.datetime


def parse_validity_from_pem_file(path: str) -> CertValidity:
    with open(path, 'rb') as f:
        return parse_validity_from_pem(f.read())


def parse_validity_from_pem(pem: bytes) -> CertValidity:
    der = ssl.PEM_cert_to_DER_cert(pem.decode('ascii'))
    return parse_not_after_from_der(der)


def parse_not_after_from_der(der: bytes) -> CertValidity:
    r = DERReader(der)

    # Certificate ::= SEQUENCE { tbsCertificate, signatureAlgorithm, signatureValue }
    cert_seq = r.read_sequence()

    # tbsCertificate ::= SEQUENCE { ... validity Validity, ... }
    tbs = cert_seq.read_sequence()

    # Skip: version (OPTIONAL, explicit [0]), serialNumber, signature, issuer
    # This is a minimal, structure‑aware skip:
    # 1) Optional version [0] EXPLICIT
    t = tbs.read_byte()
    l = tbs.read_len()

    # If this is context‑specific [0] (0xa0), it's the explicit version.
    if t == 0xa0:
        # value is an encoded Version; skip its contents using a nested reader
        tbs.pos += l
    else:
        # otherwise, we just consumed the first byte of serialNumber;
        # rewind so serialNumber parse sees full TLV
        tbs.pos -= (1 + (0 if l < 0x80 else 1))  # very simple rewind heuristic

    # Now skip: serialNumber, signature, issuer
    for _ in range(3):
        tbs.read_tlv()

    # Next field is Validity ::= SEQUENCE { notBefore, notAfter }
    validity = tbs.read_sequence()

    # notBefore Time
    tag_nb, val_nb = validity.read_tlv()
    # notAfter Time
    tag_na, val_na = validity.read_tlv()

    # Time is UTCTime (0x17) or GeneralizedTime (0x18)
    if tag_nb not in (0x17, 0x18):
        raise ValueError(f"Unexpected Time tag for notBefore: {tag_nb:#x}")
    if tag_na not in (0x17, 0x18):
        raise ValueError(f"Unexpected Time tag for notAfter: {tag_na:#x}")

    return CertValidity(parse_cert_time(val_nb), parse_cert_time(val_na))


def parse_cert_time(time_bytes: bytes) -> datetime.datetime:
    s = time_bytes.decode("ascii")
    # UTCTime: YYMMDDHHMMSSZ, GeneralizedTime: YYYYMMDDHHMMSSZ
    if re.fullmatch(r"\d{12}Z", s):  # UTCTime
        dt = datetime.datetime.strptime(s, "%y%m%d%H%M%SZ")
        year = dt.year
        if year < 1950:
            year += 100  # RFC 5280: 1950–2049 window
            dt = dt.replace(year=year)
        return dt
    elif re.fullmatch(r"\d{14}Z", s):  # GeneralizedTime
        return datetime.datetime.strptime(s, "%Y%m%d%H%M%SZ")
    else:
        raise ValueError(f"Unsupported Time encoding: {s!r}")


class DERReader:
    def __init__(self, data: bytes) -> None:
        self.data = data
        self.pos = 0

    def read_byte(self) -> int:
        b = self.data[self.pos]
        self.pos += 1
        return b

    def read_len(self) -> int:
        first = self.read_byte()
        if first < 0x80:
            return first
        nbytes = first & 0x7F
        if nbytes == 0 or nbytes > 4:
            raise ValueError("Unsupported length form")
        val = 0
        for _ in range(nbytes):
            val = (val << 8) | self.read_byte()
        return val

    def read_tlv(self) -> tuple[int, bytes]:
        tag = self.read_byte()
        length = self.read_len()
        start = self.pos
        end = start + length
        if end > len(self.data):
            raise ValueError("Length beyond end")
        self.pos = end
        return tag, self.data[start:end]

    def read_sequence(self) -> "DERReader":
        tag, value = self.read_tlv()
        if tag != 0x30:  # SEQUENCE
            raise ValueError(f"Expected SEQUENCE, got tag {tag:#x}")
        return DERReader(value)
